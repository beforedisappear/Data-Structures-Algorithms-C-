<h1><p align="center"> Data Structures and Algorithms  </p></h>

<h2><p align="center">Содержание</p></h2>

- [Basic algorithms](#Basic)
- [Sets](#Set)
- [Sorting](#Sorting)
- [Singly and Doubly linked lists](#LinkedList)
- [HashTables](#HashTable)
- [Binary Tree](#BinaryTree)
- [Graph](#Graph)
- [Non-Recursive Merge and Quick sort](#IndTask)

<a name="Basic">***Базовые алгоритмы***</a>
-------------------------------------------

В классе ```ASD``` реализованы базовые методы, отражающие некоторые основные
моменты работы с алгоритмами.

Класс ```ASD``` содержит следующие методы:

1)  Числа Фибоначчи (3 способа)

> Числа Фибоначчи – это элементы числовой последовательности, которые
> определяются по формуле : ![fibonacci](https://i.imgur.com/Fa7xAtC.png)
>
> Способы задания n-го числа Фибоначчи.
>
> - Рекурсивная процедура (Метод Fibo)
>
> В данном методе происходит вызов функцией самой себя, тем самым
> формируется n-число Фибоначчи.
>
> - Нерекурсивная процедура (Метод FiboR)
>
> С помощью цикла for происходит сложение предыдущих чисел Фибоначчи.
> Изначально заданы: F1 = 1, F2 = 1, в отличии от рекурсивной
> версии.
>
> - Метод с использованием массива (Метод FiboArray)
>
> С помощью цикла for происходит сложение предыдущих массивов содержащих
> предыдущие числа Фибоначчи.

2)  Конвертирование в соответствующую систему счисления

> Метод IntConvert формирует конвертированное число в соответствии с
> элементом, взятым из алфавита Letters = "0123456789ABCDEF";

3)  Конвертирование строки в число

> Метод ConvertStringToInt преобразует строку в число с помощью класса
> Convert и встроенного метода ToInt32.

4)  Нахождение наибольшего общего делителя

> Метод NOD помогает сформировать наибольший общий делитель двух чисел с
> помощью цикла while.

5)  Проверка числа на простоту

> Метод BoolTestSimple с помощью цикла for происходит проверка всех
> делителей. В случае деления без остатка возвращается false, иначе –
> true.

6)  Метод половинного деления для нахождения корней уравнения
    (Метод PolDel)

> Метод деления пополам позволяет исключать в точности половину
> интервала на каждой итерации. При использовании метода считается, что
> функция непрерывна и имеет на концах интервала разный знак. После
> вычисления значения функции в середине интервала одна часть интервала
> отбрасывается так, чтобы функция имела разный знак на концах
> оставшейся части. Итерации метода деления пополам прекращаются, если
> интервал становится достаточно малым.

7)  Поиск минимума функции на отрезке методом золотого сечения
    (Метод GoldMin)

> Интервал неопределенности делится на две неравные части так, что
> отношение длины большего отрезка к длине всего интервала равно
> отношению длины меньшего отрезка к длине большего.


<a name="Set">***Множества***</a>
---------------------------------


*Множество* (set) представляет собой набор различных объектов, которые
называются элементами. Множество можно описать путем явного перечисления
его элементов в виде списка, заключенного в фигурные скобки. Они не
могут содержать один и тот же элемент дважды; кроме того, элементы
множества не упорядочены. Если объект *x* является элементом множества
А, то говорят, что *x* принадлежит А. Два множества (A и B) равны, если
они содержат одни и те же элементы.

Для выполнения данной работы мной был реализован обобщенный
класс ```Set<T>```, в котором параметр типа «T», реализует интерфейс
«Icomparable».

Класс ```Set<T>``` содержит два конструктора (метод необходимый для
инициализации экземпляра класса) с нижеперечисленными значениями.

Класс ```Set<T>``` принимает следующие значения:

```cs 
public int size; // размер множества
public int count; // количество элементов в множестве
public T[] data; // массив данных для формирования конечного множества
```    
    
Класс ```Set<T>``` содержит следующие методы и свойства:

1.  ```cs
    public bool Contains (T el) // проверка на наличие элемента в множестве
    
2.  ```cs
    public int GetIndex (T el) // получение индекса элемента множества
    
3.  ```cs
    public void Add (T el) // добавление нового элемента в множество

4.  ```cs
    public void Resize (int newsize) // изменение размера множества

5. ```cs
    public bool RemoveInd (int index) // удаление элемента по индексу

6.  ```cs
    public bool RemoveEL (T el) // удаление элемента по значению

7.  ```cs
    public T GetElementByIndex (int i) // получение элемента множества по индексу

8.  ```cs
    public T SetElementByIndex (int index, T newEl) // установка нового элемента по индексу

9.  ```cs
    public static Set<T> Union (Set<T> s1, Set<T> s2) // объединение множеств

10. ```cs
    public static Set<T> Intersection (Set<T> s1, Set<T> s2) // пересечение множеств

11. ```cs
    public static Set<T> Addition (Set<T> s1, Set<T> s2) // дополнение множества

12. ```cs
    public List<Set<T>> SelectSets()  // получение набора множеств из последовательности элементов множества
    
13. ```cs
    public void Allsubsets(T[] list) // поиск всех подмножеств множества

14. ```cs
    public override string ToString() // преобразование object в строковое представление
    ```

*Пересечением множеств А и В* называется множество, обозначаемое
*А*⋂*В*, состоящее из всех объектов, каждый из которых принадлежит обоим
множествам *А* и *В* одновременно.

![intersection](https://i.imgur.com/IyjlHk9.png?1)

*Объединением множеств А и В* называется множество, обозначаемое *А*
∪*В,* состоящее из всех объектов, каждый из которых принадлежит хотя бы
одному множеству *А* или *В.*

![union](https://i.imgur.com/YUeLwYb.png?1)

*Дополнением* множества А до множества B называется совокупность
элементов множества B, которые не входят в множество A. Данное 
множество можно получить если произвести разность множеств А и B.

![addition](https://i.imgur.com/67gifFv.png)

В классе ```Program``` создаются объект класса ```Set<T>``` и соответствующие
примеры.


<a name="Sorting">***Сортировки***</a>
--------------------------------------


*Сортировка* — это упорядочивание набора однотипных данных по возрастанию или убыванию. При сортировке элементов в массиве выполняются две основных операции: сравнения элементов по ключу сортировки и  пересылка элементов. Для выполнения данной работы мной был реализован  класс MySort. В нем было реализовано множество различных методов (сортировок), где параметр типа «T» реализует интерфейс «Icomparable».

В классе ```MySort``` представлены следующие методы:

```cs
public static void BubbleSort<T>(T[] arr) // пузырьковая сортировка
```
Свое образное название этот метод получил в силу одной своей особенности: при сортировке по возрастанию отсортированная часть массива формируется
путем выталкивания («всплывания») при каждом просмотре наибольшего из значений в неотсортированной части массива. Соответственно, при сортировке по убыванию «всплывают» минимальные значения. Происходит последовательное сравнение значений соседних элементов и смена чисел местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими значениями оказываются в конце списка, а с меньшими остаются в начале.

В сортировке методом пузырька количество итераций внешнего цикла определяется длинной массива минус единица, так как когда второй элемент становится на свое место, то первый уже однозначно минимальный и находится на своем месте. То есть за первую итерацию максимальное число становится на свое место.

```cs
public static void SelectionSort<T>(T[] arr) // cортировка выбором
```

Это простой и наиболее очевидный способ сортировки. Соответствующий
алгоритм можно описать следующим образом.

> − Среди элементов массива выбирается элемент с наименьшим значением.
>
> − Выбранный элемент меняется местами с первым элементом массива.

После этого массив можно рассматривать как состоящий из двух частей: левой – уже отсортированной, и правой – неотсортированной. Повторное
применение шагов 1 и 2, но уже к неотсортированной части массива приведет к ее уменьшению на один элемент и, соответственно, к увеличению
на один элемент отсортированной части массива. Алгоритм повторяется до тех пор, пока массив не будет отсортирован (размерность неотсортированной части массива равна единице).

```cs
public static void InsertionSort<T>(T[] arr) // cортировка вставкой
```

В этом варианте алгоритма включение нового элемента в отсортированную часть осуществляется путем последовательного сдвига данного элемента
влево. Этот процесс может завершиться при выполнении одного из двух условий:

> − следующий элемент меньший, чем включаемый;
>
> − достигнута права граница массива.

Ниже продемонстрирована работа данного алгоритма на последнем шаге сортировки. Выполнилось условие, что следующий элемент (4) меньше, чем включаемый (7) и произошел выход из цикла. Далее “указатель” достигает правой границы массива, что означает завершение процесса сортировки.

![insertionsort](https://i.imgur.com/JbrydVv.png)

```cs
public static void ShakerSort<T>(T[] arr)  // шейкер сортировка (перемешиванием)
```

Шейкер сортировка представляет собой двунаправленную пузырьковую
сортировку. Следующие идеи помогают улучшить пузырьковую сортировку:

> − условием завершения процесса сортировки считать отсутствие парных
> перестановок при очередном просмотре;
>
> − сравнение пар элементов производить только до места последней
> перестановки: раз не было перестановок, значит дальше элементы
> упорядочены;
>
> − чередовать направления просмотра, что позволит одновременно
> формировать две отсортированные области – в левой и правой частях
> массива. При прохождении массива слева направо (снизу вверх) поднимается
> легкий пузырек. При прохождении массива справа налево (сверху вниз)
> опускается тяжелый пузырек. (После первого двухстороннего прохода мы в
> начало и конец массива помещаем соответственно минимальный и
> максимальный элемент).

```cs
public static void ShellSort<T>(T[] arr) // cортировка Шелла
```

Этот метод является усовершенствованием метода вставок. Суть его
заключается в разбиении сортируемого массива на ряд цепочек из
равноотстоящих друг от друга элементов. Расстояние между элементами
одной цепочки (шаг цепочки) первоначально выбирается достаточно большим
(половина длины массива). Элементы каждой из цепочек сортируются обычным
методом вставок. Однако перестановка значений элементов, находящихся на
больших расстояниях друг от друга, позволяет существенно повысить
эффективность алгоритма. При последующих просмотрах шаг цепочек
уменьшается до тех пор, пока он не станет равным 1. И тогда процесс
сортировки будет идентичен процессу обычной сортировки вставкой.

Невзирая на то, что сортировка Шелла во многих случаях медленнее, чем
быстрая сортировка, она имеет ряд преимуществ: отсутствие потребности в
памяти под стек; отсутствие деградации при неудачных наборах данных —
быстрая сортировка легко деградирует до O(n²), что хуже, чем худшее
гарантированное время для сортировки Шелла.

```cs
public static int BinSearch<T>(T[] arr, T el) // бинарный поиск
```

Поиск можно значительно ускорить, если массив упорядочен, например, по
возрастанию. В этом случае чаще всего применяется метод деления пополам
или бинарный поиск. Суть этого метода заключается в следующем. Сначала
искомый элемент сравнивается со средним элементом массива. Если искомый
элемент больше среднего, то поиск продолжается в правой части массива,
если меньше среднего – то в левой части. При каждом сравнении из
рассмотрения исключается половина элементов – не имеет смысла искать
элемент больше среднего в левой части, содержащей меньшие значения.
Максимальное число требующихся сравнений равно log2(N).

```cs
public static T[] QuickSort<T>(T[] arr, int minindex, int maxindex) // быстрая сортировка
```
```cs
public static int Partition<T>(T[] arr, int minindex, int maxindex) // метод для поиска разделяемого элемента в быстрой сортировке
```

Быстрая сортировка, подобно сортировке слиянием, применяет принцип
"разделяй и властвуй". Ниже описан процесс сортировки массива А[р..r].

*Разделение*

Массив А[р..r] разбивается на два (возможно, пустых) подмассива 
A[p..q-1] и A[q+1..r], таких, что каждый элемент А[p..q-1]
меньше или равен А[q], который, в свою очередь, не превышает любой 
элемент подмассива A[q+1..r]. Индекс q вычисляется в ходе процедуры 
разбиения.

*Властвование* 

Подмассивы A[p..q-1] и A[q+1..r] сортируются с
помощью рекурсивного вызова процедуры быстрой сортировки.

*Комбинирование*

Поскольку подмассивы сортируются на месте, для их
объединения не требуются никакие действия, весь массив А[р..r]
оказывается отсортированным.

*Разбиение массива*

Ключевой частью рассматриваемого алгоритма
сортировки является процедура Partition, изменяющая порядок элементов
подмассива А[р..r] иначе A[p..q-1] или A[q+1..r] без привлечения
дополнительной памяти.

В более кратком виде данный алгоритм можно описать следующими
действиями:

>1.  Выбираем в качестве опорного элемента последний элемент
>    массива (pivot).
>
>2.  Располагаем слева элементы, которые меньше опорного элемента, а
>    справа больше опорного элемента. Слева и справа мы получаем
>    два подмассива.
>
>3.  Далее, повторяем это действие для полученных подмассивов снова и
>    снова (рекурсивно), пока весь массив не будет отсортирован.

На схеме ниже продемонстрирован процесс данной сортировки на примере
массива из 8 элементов.

![quicksort](https://i.imgur.com/xzFkt0K.png)

```cs
public static T[] MergeSort<T>(T[] arr, int minindex, int maxindex) // сортировка слиянием
```

```cs
public static void Merge<T>(T[] arr, int minindex, int middleindex, int maxindex) // метод для слияния массивов
```

Подобно QuickSort, MergeSort является алгоритмом класса "Разделяй и
властвуй". Он делит входной массив на две половины, вызывается
рекурсивно от каждой из получившихся половин, а затем объединяет две
отсортированные половины. Функцию Merge() будем использовать для слияния
двух половин.

Алгоритм:

>1.  Определяем middleindex (индекс, по которому будет
>    осуществляться разбиение).
>
>2.  Исходный массив делится на две примерно равные части. Если массив
>    имеет нечетное количество элементов, одна из этих «половин» на один
>    элемент больше, чем другая.
>
>3.  Подмассивы делятся снова и снова на две половины, пока вы не
>    получите массивы, которые имеют только один элемент каждый.
>
>4.  Затем объединяем пары одноэлементных массивов в двухэлементные
>    массивы, сохраняя их в процессе. Затем эти отсортированные пары
>    объединяются в четырехэлементные массивы и так далее до тех пор,
>    пока не будет получен исходный отсортированный массив.

![mergesort](https://i.imgur.com/7b3fyFd.png)


В классе ```Program``` создаются объект класса ```MySort``` и соответствующие
примеры.


<a name="LinkedList">***Односвязные и двусвязные списки***</a>
---------------------------------------------------------------


*Связный список* (linked list) – это структура данных, в которой объекты
расположены в линейном порядке. Однако, в отличие от массива, в котором
этот порядок определяется индексами, порядок в связанном списке
определяется указателями на каждый объект. Связанные списки обеспечивают
простое и гибкое представление динамических множеств и поддерживают
операции поиска, удаления, вставки и тд.

<h3><p align="center">I)  Односвязные списки </p></h3>

Односвязный список (single linked list) представляет набор связанных
узлов, каждый из которых хранит собственно данные и ссылку на следующий
узел. Последний элемент списка указывает на NULL (отсутствие). Элемент,
на который нет указателя, является первым (головным) элементом списка.
Здесь ссылка в каждом узле указывает на следующий узел в списке. В
односвязном списке можно передвигаться только в сторону конца списка.

В реальной жизни связный список можно представить в виде поезда, каждый
вагон которого может содержать некоторый груз или пассажиров и при этом
может быть связан с другим вагоном.

![slist](https://i.imgur.com/8yQSCcV.png)

Для реализации односвязного списка мной были созданы следующие классы:

1)  ```class SingleNode<T>``` - обобщенный класс для создания данных
    об узле.

Класс принимает следующие значения и свойства:

```cs
public int Key { get; set; } // ключ узла
public T Value { get; set; } // значение узла
public SingleNode<T> Next { get; set; }  // ссылка на следующий узел
```

Класс также содержит два конструктора (пустой и с вышеперечисленными
данными) и метод ToString() для преобразования данных об узле в
строковое представление.

2)  ```class SingleList<T>``` - обобщенный класс для создания методов
    односвязного списка.

Класс принимает следующие значения и свойства:

```cs
public int Count { get; set; } // свойство, определяющее количество узлов (элементов) в списке
```

```cs
SingleNode<T> head; // ссылка на головной (первый) узел
```
И методы:

```cs
public void AddHead(int k, T v) // добавление узла в начало (обновление head)
```
Ниже продемонстрирован процесс добавления нового узла в начало односвязного списка.
![addhead](https://i.imgur.com/PSb3AYt.png)

```cs
public void AddEnd(int k, T v) // добавление узла в конец (обновление Next у последнего узла)
```
Ниже продемонстрирован процесс добавления узла в конец односвязного списка.
![addend](https://i.imgur.com/nyxV8vY.png)

```cs
public void RemoveHead() // удаление головного (первого) узла
```
![removehead](https://i.imgur.com/N8tTe1q.png)

```cs
public void RemoveEnd() // удаление последнего узла
```
![removeend](https://i.imgur.com/CLa4n3Z.png)

```cs
public bool IsContainsByValue(T value) // проверка на наличие в списке узла с определенным значением
```

Все методы поиска основаны на переборе всех узлов списка с начала.

```cs
public SingleNode<T> FindByValue(T value) // поиск узла по значению
```
```cs
public SingleNode<T> FindByIndex(int index) // поиск узла по индексу (0,1,2,3…)
```
```cs
public SingleNode<T> FindByKey(int key) // поиск узла по ключу
```

Методы вставки:
```cs
public void InsertByBeforeValue(T select, int k, T v) // вставка нового узла перед выбранным узлом
```
![insertvalue](https://i.imgur.com/gEtfIcn.png)
```cs
public void InsertByAfterValue(T select, int k, T v) // вставка нового узла после выбранного узла
```
Процесс вставки нового узла ПОСЛЕ выбранного значения примерно
соответствует вставке ПЕРЕД выбранным значением (продемонстрированным
на схеме выше), отличие заключается лишь в формировании ссылок для узлов.

Методы удаления узлов:
```cs
public bool RemoveByValue(T value) // удаление узла по значению
```
```cs
public bool RemoveByIndex(int index) // удаление узла по индексу
```
```cs
public bool RemoveByKey(int key) // удаление узла по ключу
```

Идея удаления узла по выбранному значению/индексу/ключу
продемонстрирована ниже. Отличие состоит в способе поиска удаляемого
узла.

![removeby](https://i.imgur.com/yKD8hZT.png)

```cs
public void View() // метод для вывода данных об узлах (значение и ключ) 
```
Благодаря последовательному выводу узлов всего списка (от
начала к концу), данный метод отображает также связь между узлами.

Идея данного метода заключается в последовательном выводе всех узлов,
пока ссылка Next не будет равна Null (следующий узел отсутствует).

<h3><p align="center">II)  Двусвязные списки </p></h3>

Двусвязные списки (Double Linked List) также представляют
последовательность связанных узлов, однако теперь каждый узел хранит
ссылку на следующий и на предыдущий элементы. Двунаправленность списка
приходится учитывать при добавлении или удалении элемента, так как кроме
ссылки на следующий элемент надо устанавливать и ссылку на предыдущий.
Но в то же время у нас появляется возможность обходить список как от
первого к последнему элементу, так и наоборот - от последнего к первому
элементу. В остальном двусвязный список ничем не будет отличаться от
односвязного списка.

![dlist](https://i.imgur.com/S7AVKgI.png)

Для реализации двусвязного списка мной были созданы следующие классы:

1)  ```class DoubleNode<T>``` – обобщенный класс для создания данных об узле.

Класс принимает следующие значения и свойства:
```cs
public int Key { get; set; } // ключ узла
public T Value { get; set; } // значение (данные) узла
public DoubleNode<T> Next { get; set; }  // ссылка на следующий узел
public DoubleNode<T> Prev { get; set; } // ссылка на предыдущий узел
```

Класс также содержит два конструктора (пустой и с вышеперечисленными
данными) и метод ToString() для преобразования данных об узле в
строковое представление.

2)  ```class DoubleList<T>``` – обобщенный класс для создания методов
    двусвязного списка.

Класс принимает следующие значения и свойства:

```cs
public int Count { get; set; } // количество узлов(элементов) в списке
DoubleNode<T> head;  // ссылка на головной (первый) узел
DoubleNode<T> tail; // ссылка на хвостовой (последний) узел
```
И методы:

```cs
public void AddHead(int k, T v) // добавление узла в начало (обновление head)
```
![addhead2](https://i.imgur.com/NU6HRbC.png)

```cs
public void AddEnd(int k, T v) // добавление узла в конец (обновление tail)
```
![addend2](https://i.imgur.com/sj9STSY.png)

```cs
public bool IsContainsByValue(T value) // проверка на наличие в списке узла с определенным значением
```

```cs
public void RemoveHead() // удаление головного (первого) узла
```
![removehead2](https://i.imgur.com/juMsQEh.png)

```cs
public void RemoveEnd() // удаление хвостового (последнего) узла
```
Идея удаления последнего элемента похожа на идею, представленную в
методе RemoveHead. Отличие заключается в том, что узел удаляется
справа и уже Next принимает значение NULL.

Методы удаления узлов:
```cs
public bool RemoveByValue(T value)
```

```cs
public bool RemoveByKey(int index)
```

```cs
public bool RemoveByIndex(int key)
```
Идея удаления узла по выбранному значению/индексу/ключу
продемонстрирована ниже. Отличие состоит в способе поиска удаляемого
узла.

![removehead2](https://i.imgur.com/UdJk0MU.png)

Все методы поиска основаны на переборе всех узлов списка с начала.
```cs
public DoubleNode<T> FindByValue(T value) // поиск узла по значению
```
```cs
public DoubleNode<T> FindByKey(int key) // поиск узла по ключу
```
```cs
public DoubleNode<T> FindByIndex(int index) // поиск узла по индексу (0,1,2,3…)
```
Методы вставки:
```cs
public void InsertByAfterValue(T select, int k, T v) // вставка нового узла после выбранного узла
```
![insertby2](https://i.imgur.com/ynsUiTV.png)
```cs
public void InsertByBeforeValue(T select, int k, T v) // вставка нового узла перед выбранным узломx
```
Процесс вставки нового узла ПОСЛЕ выбранного значения примерно
соответствует вставке ПЕРЕД выбранным значением (продемонстрированным
на схеме выше), отличие заключается лишь в формировании ссылок для
узлов.

```cs
public void ViewForward() // метод для вывода данных об узлах (отображение двусвязного списка)
                          // (значение и ключ) при проходе по списку от начала до конца
```
```cs
public void ViewBack() // метод для вывода данных об узлах (отображение двусвязного списка)
                       // (значение и ключ) при проходе по списку от конца к началу 
```

В классе ```Program``` создаются односвязные и двусвязные списки, там же к ним
применяются соответствующие методы.


<a name="HashTable">***Хеш – таблицы***</a>
-------------------------------------------


*Хеш-таблица* представляет собой эффективную структуру данных для
реализации словарей. Время выполнения алгоритмов простого и бинарного
поиска зависит от размера массива. Идея хеширования заключается в том,
чтобы эту зависимость убрать. Это достигается установлением
функциональной зависимости между значением элемента массива и его
индексом. В этом состоит суть так называемой ассоциативной адресации.
Массив, сформированный по принципу ассоциативной адресации, называется
*Хеш-таблицей*. Функция, устанавливающая связь между значением элемента
и индексом элемента, называется *Хеш-функцией*. Значение, используемое в
качестве аргумента хеш-функции, будем далее называть *ключом*.

Хотя на поиск элемента в хеш-таблице может в наихудшем случае
потребоваться столько же времени, сколько на поиск в связанном списке,
на практике хеширование исключительно эффективно. При вполне
обоснованных допущениях среднее время поиска элемента в хеш-таблице
составляет О(1). Принцип работы данной структуры схож с каталогом книг.
Все книги разложены в алфавитном порядке, но не на одном стеллаже, а для
каждой буквы выделен отдельный стеллаж, поэтому нам не нужно по порядку
перебирать все книги, а можно подойти к нужному стеллажу и искать уже
там.

*Хеширование*

Пусть k – ключ, а h(x) – хеш-функция. Тогда h(k) в результате даст
индекс, в котором мы будем хранить элемент, связанный с k.

*Коллизия*

Ситуация, когда для разных ключей получается одно и то же хеш-значение,
называется *коллизией* или столкновением. Двумя распространенными
методами борьбы с коллизиями являются:

> 1. Метод цепочек.
> 
> Каждая ячейка хеш-таблицы — это список значений. При возникновении
> коллизии, новое значение просто добавляется в список в ту же ячейку
> таблицы.
>
> 2. Открытая адресация
> 
> Суть данного способа заключается в поиске первой пустой ячейки после
> той, на которую указала хеш-функция.

Для реализации хеш-таблиц мной было создано 2 класса:

1)  ```HTarray``` – обобщенный класс для реализации хеш-таблиц на основе
    массивов (с использованием открытой адресации).

Класс принимает следующие значения:
```cs
public SingleNode<T>[] htArray; // массив, элемент которого создан на основе узла односвязного списка (содержит все значения)
public int[] active; // массив для активных (занятых) ячеек
public int Size; // размер хеш-таблицы (максимальное возможное количество ячеек)
public int Count; // количество всех элементов в хеш-таблицы
```

Класс ```HTarray``` содержит конструктор с вышеперечисленными значениями.

И методы:
```cs
public int HashCode(int key) // метод, возвращающий хеш-функцию (определяет индекс)
```

```cs
public void Add(int key, T value) // добавление нового элемента в свободную ячейку
```

```cs
public SingleNode<T> SearchByKey(int key) // поиска элемента по ключу
```

```cs
public int SearchIndex(int key) // поиск индекса ячейки по ключу
```

```cs
public void RemoveByKey(int key) // удаление элемента из ячейки по ключу
```

```cs
public void Resize(int newsize) // изменение размера хеш-таблицы.
```

```cs
public void View() // метод для отображения хеш-таблицы (вывод данных о ячейках)
```

2)  ```HTlist``` – обобщенный класс для реализации хеш-таблиц на основе
    списков (с использованием метода цепочек).

Класс принимает следующие значения:
```cs
public List<SingleNode<T>>[] htLists; // массив списков, элемент которого создан на основе узла односвязного списка (содержит все значения)
```

```cs
public int Size; // размер хеш-таблицы (максимальное возможное количество ячеек)
```

```cs
public int Count; // количество всех элементов в хеш-таблицы.
```
Класс ```HTarray``` содержит конструктор с вышеперечисленными значениями.

И методы:
```cs
public int HashCode(int key) // метод, возвращающий хеш-функцию (определяет индекс)
 ```
 
 ```cs
public void Adds(int key, T value) // добавление нового элемента в любую ячейку
```

```cs
public void RemoveByKey(int key) // удаление элемента из ячейки по ключу
```

```cs
public void Resize(int newsize) // изменение размера хеш-таблицы
```

```cs
public SingleNode<T> SearchByKey(int key) // поиска элемента по ключу
```

```cs
public void View() // метод для отображения хеш-таблицы (вывод данных о ячейках)
```

В классе ```Program``` создаются хеш-таблицы на основе массивов и списка с
различными способами решения коллизии, а также применяются
соответствующие методы к ним.

<a name="BinaryTree">***Бинарное дерево***</a>
----------------------------------------------

Деревья имеют широкое применение при реализации трансляторов таблиц
решений, при работе с арифметическими выражениями, при создании и
ведении таблиц символов, где их используют для отображения структуры
предложений, в системах связи для экономичного кодирования сообщений и
во многих других случаях.

*Бинарное дерево* является динамической иерархической структурой данных,
в которой каждый узел имеет не более двух дочерних узлов. Как правило,
первый называется родительским узлом или корнем дерева (root), а
дочерние узлы называются левым и правым наследниками (потомками). При
отсутствии соответствующих поддеревьев эти поля получают значение null,
и называются листьями. В процессе выполнения программы деревья создаются
и модифицируются путем добавления и удаления узлов, а также изменения их
информационной части.

Бинарное дерево является *упорядоченным* (деревом, у которого для
каждого узла Node значение левого дочернего узла меньше, чем значение в
Node, а значение правого дочернего узла больше значения в Node). Если в
дереве могут содержаться одинаковые значения, то программист сам должен
определить, влево или вправо помещать значение, равное значению в
родительском узле, то есть соответствующее строгое неравенство заменить
на нестрогое.

![binarytree](https://i.imgur.com/4HTt5Rp.png)

Для реализации бинарных деревьев мной было создано 2 класса:

1)  ```BinaryNode<T>``` - обобщенный класс для создания данных об узле дерева.

Класс принимает следующие значения и свойства:

```cs
public int Key; // ключ узла.
public T Value; // значение узла.
public BinaryNode<T> Parent; // ссылка на родительный узел
public BinaryNode<T> Right; // ссылка на правый дочерний узел (правый потомок/наследник)
public BinaryNode<T> Left; // ссылка на левый дочерний узел (левый потомок/наследник)
```

Класс также содержит два конструктора (пустой и с вышеперечисленными
данными) и метод ToString() для преобразования данных об узлах и их
ссылках в строковое представление.

2)  ```BinaryTree<T>``` - обобщенный класс для создания методов
    бинарного дерева.

Класс принимает следующее значение и содержит конструктор:

```cs
public BinaryNode<T> root; // корень дерева
```

```cs
public BinaryTree() // инициализация корня дерева, то есть создание дерева
```
И методы:

```cs
public void AddNodeInThree(int k, T v) // добавление нового узла в дерево
```
Добавление происходит по одному из случаев:
>1.  Ключ добавляемого узла больше ключа корня, тогда идем в правую
>    часть дерева.
>
>2.  Ключ добавляемого узла меньше ключа корня, тогда идем в левую
>    часть дерева.
>
>3.  Ключ корня равен ключу добавляемого узла, тогда не добавляем узел.

```cs
public BinaryNode&lt;T&gt; Search(int k) – поиск узла по ключу
```

```cs
public bool DeleteNode(int key) – удаление узла
```

Для удаления узла из бинарного дерева поиска нужно рассмотреть три
возможные ситуации. Если у узла нет дочерних узлов, то у его родителя
нужно просто заменить указатель на null. Если у узла есть только один
дочерний узел, то нужно создать новую связь между родителем удаляемого
узла и его дочерним узлом.

Наконец, если у узла два дочерних узла, то нужно найти следующий за
ним по значению элемент, его потомков подвесить на родительский узел
найденного элемента, а удаляемый узел заменить найденным узлом. Таким
образом, свойство бинарного дерева поиска не будет нарушено.

![deletingnode](https://i.imgur.com/htTcTMw.png)

```cs
public BinaryNode<T> MinNode(BinaryNode<T> tmp) // поиск узла c минимальным значением ключа от указанной вершины
```

```cs
public BinaryNode<T> MaxNode(BinaryNode<T> tmp) // поиск узла c максимальным значением ключа от указанной вершины
```

```cs
public void ViewAscending(BinaryNode<T> tmp) // отображение бинарного дерева по возрастанию ключей
```

```cs
public void ViewDescending(BinaryNode<T> tmp) // отображение бинарного дерева по убыванию ключей
```

```cs
public void ViewOrder(BinaryNode<T> tmp) // отображение бинарного дерева 
                                         // (обход в прямом порядке, то есть от корня, пока не дойдем до листьев)
```
В классе ```Program``` создаются бинарные деревья, а также применяются
соответствующие методы к ним.


<a name="Graph">***Графы***</a>
-------------------------------------

*Графом* G называется пара множеств (V, E), где E – произвольное
подмножество из V (то есть V –конечное множество вершин, а Е — отношение
на V). Элементы множеств V и E соответственно называются вершинами и
ребрами графа G.

Если V1, V2 – вершины, а e = (v1, v2) – соединяющее их ребро, тогда
вершина V1 и ребро e инцидентны, вершина v2 и ребро e тоже инцидентны.
Два ребра, инцидентные одной вершине, называются смежными; две вершины,
инцидентные одному ребру, также называются смежными

Различают два основных вида графов: ориентированные и неориентированные.

Граф G называется *ориентированным* графом (орграфом), если все его
ребра являются ориентированными. Ориентированные ребра называют дугами.
Дуга описывается как упорядоченная пара вершин (v, w), где вершину v
называют началом, а w – концом дуги. Говорят, что дуга v → w ведет от
вершины v к смежной с ней вершине w.

*Неориентированный* граф – это набор вершин, некоторые из которых
соединены ребрами. Его можно считать частным случаем ориентированного
графа, в котором для каждого ребра есть обратное ребро.

![graphs](https://i.imgur.com/vvlf1U5.png)

Графы обычно представлены тремя способами: матрица смежности, список
смежности и матрица инцидеций.

Для реализации графов мной были созданы следующие классы:

1)  ```Vertex``` – обобщенный класс для создания данных о вершине.

Класс принимает следующие значения и свойства:

```cs
public string Name { get; set; } // название вершины
public Vertex prevVertex; // предыдущая вершина (от которой пришли при обходе графа)
public double distance; // расстояние, которое прошли при посещении вершины
public List<Edge> AdjEdges; // набор смежных ребер
public ColorVertex color; // цвет вершины (для обхода в глубину и ширину)
```

Класс также содержит два конструктора (пустой и с вышеперечисленными
данными), перечисление ```public enum``` для раскраски вершин и метод
ToString() для преобразования данных о вершине в строковое
представление.

2)  ```Edge``` – обобщенный класс для создания данных о ребре.

Класс принимает следующие значения и свойства:

```cs
public Vertex From { get; set; } // откуда идет ребро
public Vertex To { get; set; } // куда идет ребро
public double Weight { get; set; } // вес ребра
```

Класс также содержит два конструктора (пустой и с вышеперечисленными
данными), и метод ToString() для преобразования данных о ребре в
строковое представление.

3)  ```Graph``` – обобщенный класс для создания методов о графе.

Класс принимает следующие значения и свойства:

```cs
public List<Vertex> Vertices = new List<Vertex>() // список всех вершин графа
public List<Edge> AllEdges = new List<Edge>(); // список всех ребер графа
public int VertexCount { get { return Vertices.Count; } } // количество вершин графа
public int EdgeCount { get { return AllEdges.Count; } } // количество ребер графа
```

И методы:

```cs
public void AddVertex(Vertex vertex) // добавление вершины в граф
```

```cs
public bool AddEdge(Vertex from, Vertex to) // добавление ребра в граф
```

```cs
public void RemoveVertex(Vertex vertex) // удаление вершины в графе
```

```cs
public bool VertexIsContains(Vertex vertexName) // проверка графа на наличие вершины
```

```cs
public Vertex FindVertex(Vertex vertexName) // поиск вершины по названию вершины
```

```cs
public void View() // отображение графа
```

Обход графов.

Для отметки (посещения) применяется система раскрашивания вершин графа в
один из трёх цветов: белый (white), серый (gray), чёрный (black). До
обхода графа в глубину все его вершины «красятся» в белый цвет. При
посещении вершины она приобретает серый цвет. А при возвратном
прохождении через вершину она красится в чёрный. Посещать разрешается
только белые вершины, серый цвет служит признаком прохождения вершины
при обходе в глубину с последующим возвратом через неё.

```cs
public void BFS(Vertex startVertex) // поиск в ширину (обход графа)
```

Пусть выделена исходная вершина *s*. Алгоритм поиска в ширину
систематически обходит все ребра для «открытия» всех вершин, достижимых
из *s*, вычисляя при этом расстояние от *s* до каждой достижимой из вершины.
Алгоритм работает как для ориентированных, так и для неориентированных
графов. Поиск в ширину имеет такое название потому, что в процессе
обхода мы идём вширь, то есть перед тем, как приступить к поиску вершин
на расстоянии *k+1*, выполняется обход вершин на расстоянии *k*.

Ниже представлена схема обхода графа в ширину.

![bfs](https://i.imgur.com/RQFS8NV.png)

```cs
public void DFS(Vertex startVertex) // поиск в глубину (обход графа)
```

```cs
public void DFS_Visit(Vertex u) // вспомогательный метод DFS
```

При обходе графа в
глубину начинают с некоторой вершины и просматривают по очереди все
вершины, смежные с ней. Для каждой из этих вершин этот процесс
просмотра повторяется. Другими словами, при обходе графа в глубину
происходит максимально возможное продвижение по графу от начальной
вершины с последующим возвратом в неё. Для избегания зацикливания уже
просмотренные вершины помечаются как просмотренные и в дальнейшем в
обходе в глубину они уже не участвуют.

Ниже представлена схема обхода графа в глубину.

![dfs](https://i.imgur.com/8kIAkzb.png)

```cs
public int GraphConnectivity() // связность графа
```

Данный метод основан на методе BFS.Изначально любой граф имеет 1
компоненту связи. Если после обхода остались не посещённые вершины
(белые), счетчик увеличивается на единицу и обход совершается ещё раз.

Связный граф – граф, содержащий ровно одну компоненту связности. Это
означает, что между любой парой вершин этого графа существует как
минимум один путь. Связность графа – это количество независимых графов
(подграфов).

Ниже продемонстрирован граф с 3-мя компонентами связи.

![connnectivity](https://i.imgur.com/UEXGgJR.png)

```cs
public void PrintWay(Vertex startVertex, Vertex vertex) // метод для отображения работы DFS
```
В классе ```Program``` создаются графы, а также применяются соответствующие
методы к ним.


<a name="IndTask">***Реализация QuickSort и MergeSort неркурсивным способом***</a>
----------------------------------------------------------------------------------


В работе “Сортировки” крайне подробно изложен
рекурсивный алгоритм быстрой сортировки и сортировки слиянием.  
Для выполнения данной работы мной был создан 
обобщенный класс ```IndTask```, в котором описаны
следующие методы:

```cs
public static T[] QuickSortNR<T>(T[] arr, int minindex, int maxindex) // нерекурсивная быстрая сортировка
```
```cs
public static int partition<T>(T[] arr, int minindex, int maxindex)  // метод для поиска разделяемого элемента(pivot) 
                                                                     // в быстрой сортировке (вспомогательный метод)
```
Для выполнения нерекурсивной быстрой сортировки
используем стек,
в котором хранятся интервалы сортируемых подмассивов. Каждый раз, когда
возникает необходимость в сортировке подмассива, его “координаты”
выталкиваются из стека. После разделения массива получаются два
подмассива, требующие дальнейшей обработки. Их “координаты” и
заталкиваются в стек.

Стек – один из видов разделения оперативной памяти. Его можно
представить как стопку спичечных коробков, в каждой из которых лежат
данные. Работа со стеком осуществляется по принципу LIFO (Last in –
последний вошёл, First out – первый вышел, и никак иначе). Желая
получить данные из стека, мы можем взять их только сверху и никогда из
середины.

![stack](https://i.imgur.com/IzHek9S.png)

Данная реализация использует стек, заменяя рекурсивные вызовы помещением
в стек параметров функции, а вызовы процедур и выходы из них — циклом,
который осуществляет выборку параметров из стека и их обработку, пока
стек не пуст. Мы помещаем “координаты” большего из двух подмассивов в
стек первым с тем, чтобы максимальная глубина стека при
сортировке N элементов не превосходила величины log(n).

Алгоритм работы:

>1.  Выбираем в качестве опорного элемента последний элемент
>    массива (pivot).
>
>2.  Располагаем слева элементы, которые меньше опорного элемента, а
>    справа больше опорного элемента. Слева и справа мы получаем
>    два подмассива.
>
>3.  Помещаем координаты левого и правого подмассива в стек.
>
>4.  Пока стек не пустой, производим сортировку подмассивов.
>
>       a.  Повторяем действия из a и b снова и снова, пока правый и левый
>        подмассивы не будут отсортированы.
>
>       b.  Получаем из стека координаты правого подмассива (производим
>        сортировку, повторяя пункт 1 и 2).
>
>       c.  Получаем из стека координаты левого подмассива (производим
>        сортировку, повторяя пункт 1 и 2).
>
>5.  После опустошения стека, выходим из цикла и возвращаем
>    отсортированный массив.

Алгоритм сортировки соответствует схеме, представленной в лабораторной
работе №3, только после определения опорного элемента сортирует
подмассивы не слева направо, а справа налево.

```cs
public static T[] MergeSortNR<T>(T[] arr) // нерекурсивная сортировка слиянием (головной метод)
```

```cs
public static void MergePass<T>(T[] arr, int gap, int length) // метод для разбиения массива на части (вспомогательный метод №1)
```

```cs
public static void Merge<T>(T[] arr, int minindex, int middleindex, int maxindex) // метод для слияния массивов (вспомогательный метод №2)
```
В данном способе реализации рекурсию заменяет метод MergePass и
переменная gap, увеличение которой происходит в головном методе
MergeSortNR. С помощью цикла for и gap, в методе MergePass исходный
массив разбивается на подмассивы одинакового размера (исключение в
случае нечетного количества элементов в исходном массиве: последний
подмассив состоит из 1-го элемента) и сразу же сортирует их. Далее,
происходит увеличение gap в 2 раза, тем самым “разрыв” массива
сокращается в 2 раза (осуществляется объединение полученных
подмассивов). Эти действия повторяются снова и снова, пока не будет
отсортирован весь массив. Процесс сортировки элементов в методе Merge
остается неизменным по сравнению с рекурсивной версией.

Другими словами, gap – переменная разрыва, которая помогает формировать
индексы для осуществления метода Merge, его максимальное значение –
длина массива.

- **minimal** index = i;

- **middle** index = i + gap – 1;

- **maximal** index = length – 1.

Схема ниже представляет собой демонстрацию работы алгоритма
нерекурсивной сортировки слиянием.

![nonrecursivems](https://i.imgur.com/LGwN0Je.png)

Также был реализован вариант с использованием стека.

```cs
public static T[] MergeSortNR2<T>(T[] arr) // нерекурсивная сортировка слиянием (головной метод)
```

```cs
public static T[] Merge2<T>(T[] left, T[] right) // метод для слияния массивов (вспомогательный метод)
```

В данной реализация немного другая концепция замены рекурсии, функцию
которой выполняют два стека. Суть алгоритма заключается в поочередном
перебрасывании массива из стека в стек, пока тот не будет отсортирован.
Критерием выхода из цикла является содержание стеком одного элемента
(означает, что сформирован конечный отсортированный исходный массив). В
процессе перебрасывания массивов, мы выполняем сортировку и объедение
массивов с помощью метода Merge2. Сам алгоритм сортировки элементов
подобен рекурсивной версии. Суть алгоритма объединения заключается в
создании нового массива размерности равной сумме длин сортируемых
подмассивов.

Данная концепция помогает нам постоянно хранить составляющие (а не
координаты, как в случае с QuickSort) нашего исходного массива в
оперативной памяти и не перезаписывать исходный подмассив.

Ниже представлена схема, демонстрирующая алгоритм нерекурсивной
сортировки слиянием с помощью стека.

![nonrecursivems2](https://i.imgur.com/E1IF51r.png)

В классе ```Program``` создаются объект класса ```IndTask``` и соответствующие
примеры.
